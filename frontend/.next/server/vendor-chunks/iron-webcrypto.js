"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iron-webcrypto";
exports.ids = ["vendor-chunks/iron-webcrypto"];
exports.modules = {

/***/ "(action-browser)/./node_modules/iron-webcrypto/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/iron-webcrypto/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   algorithms: () => (/* binding */ algorithms),\n/* harmony export */   base64urlDecode: () => (/* binding */ base64urlDecode),\n/* harmony export */   base64urlEncode: () => (/* binding */ base64urlEncode),\n/* harmony export */   bufferToString: () => (/* binding */ bufferToString),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   hmacWithPassword: () => (/* binding */ hmacWithPassword),\n/* harmony export */   macFormatVersion: () => (/* binding */ macFormatVersion),\n/* harmony export */   macPrefix: () => (/* binding */ macPrefix),\n/* harmony export */   randomBits: () => (/* binding */ randomBits),\n/* harmony export */   seal: () => (/* binding */ seal),\n/* harmony export */   stringToBuffer: () => (/* binding */ stringToBuffer),\n/* harmony export */   unseal: () => (/* binding */ unseal)\n/* harmony export */ });\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/constants.browser.js\nvar alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js\nvar fromBase64 = (input) => {\n  let totalByteLength = input.length / 4 * 3;\n  if (input.slice(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.slice(-1) === \"=\") {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        if (!(input[j] in alphabetByEncoding)) {\n          throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n        }\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n    const chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n  return new Uint8Array(out);\n};\n\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/toBase64.browser.js\nfunction toBase64(input) {\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n  return str;\n}\n\n// src/index.ts\nvar stringToBuffer = (value) => {\n  return new TextEncoder().encode(value);\n};\nvar bufferToString = (value) => {\n  return new TextDecoder().decode(value);\n};\nvar base64urlEncode = (value) => toBase64(typeof value === \"string\" ? stringToBuffer(value) : value).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\nvar base64urlDecode = (value) => fromBase64(\n  value.replace(/-/g, \"+\").replace(/_/g, \"/\") + Array((4 - value.length % 4) % 4 + 1).join(\"=\")\n);\nvar defaults = {\n  encryption: { saltBits: 256, algorithm: \"aes-256-cbc\", iterations: 1, minPasswordlength: 32 },\n  integrity: { saltBits: 256, algorithm: \"sha256\", iterations: 1, minPasswordlength: 32 },\n  ttl: 0,\n  timestampSkewSec: 60,\n  localtimeOffsetMsec: 0\n};\nvar clone = (options) => ({\n  ...options,\n  encryption: { ...options.encryption },\n  integrity: { ...options.integrity }\n});\nvar algorithms = {\n  \"aes-128-ctr\": { keyBits: 128, ivBits: 128, name: \"AES-CTR\" },\n  \"aes-256-cbc\": { keyBits: 256, ivBits: 128, name: \"AES-CBC\" },\n  sha256: { keyBits: 256, name: \"SHA-256\" }\n};\nvar macFormatVersion = \"2\";\nvar macPrefix = `Fe26.${macFormatVersion}`;\nvar randomBytes = (_crypto, size) => {\n  const bytes = new Uint8Array(size);\n  _crypto.getRandomValues(bytes);\n  return bytes;\n};\nvar randomBits = (_crypto, bits) => {\n  if (bits < 1)\n    throw Error(\"Invalid random bits count\");\n  const bytes = Math.ceil(bits / 8);\n  return randomBytes(_crypto, bytes);\n};\nvar pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash) => {\n  const passwordBuffer = stringToBuffer(password);\n  const importedKey = await _crypto.subtle.importKey(\"raw\", passwordBuffer, \"PBKDF2\", false, [\n    \"deriveBits\"\n  ]);\n  const saltBuffer = stringToBuffer(salt);\n  const params = { name: \"PBKDF2\", hash, salt: saltBuffer, iterations };\n  const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);\n  return derivation;\n};\nvar generateKey = async (_crypto, password, options) => {\n  var _a;\n  if (!(password == null ? void 0 : password.length))\n    throw new Error(\"Empty password\");\n  if (options == null || typeof options !== \"object\")\n    throw new Error(\"Bad options\");\n  if (!(options.algorithm in algorithms))\n    throw new Error(`Unknown algorithm: ${options.algorithm}`);\n  const algorithm = algorithms[options.algorithm];\n  const result = {};\n  const hmac = (_a = options.hmac) != null ? _a : false;\n  const id = hmac ? { name: \"HMAC\", hash: algorithm.name } : { name: algorithm.name };\n  const usage = hmac ? [\"sign\", \"verify\"] : [\"encrypt\", \"decrypt\"];\n  if (typeof password === \"string\") {\n    if (password.length < options.minPasswordlength)\n      throw new Error(\n        `Password string too short (min ${options.minPasswordlength} characters required)`\n      );\n    let { salt = \"\" } = options;\n    if (!salt) {\n      const { saltBits = 0 } = options;\n      if (!saltBits)\n        throw new Error(\"Missing salt and saltBits options\");\n      const randomSalt = randomBits(_crypto, saltBits);\n      salt = [...new Uint8Array(randomSalt)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n    const derivedKey = await pbkdf2(\n      _crypto,\n      password,\n      salt,\n      options.iterations,\n      algorithm.keyBits / 8,\n      \"SHA-1\"\n    );\n    const importedEncryptionKey = await _crypto.subtle.importKey(\n      \"raw\",\n      derivedKey,\n      id,\n      false,\n      usage\n    );\n    result.key = importedEncryptionKey;\n    result.salt = salt;\n  } else {\n    if (password.length < algorithm.keyBits / 8)\n      throw new Error(\"Key buffer (password) too small\");\n    result.key = await _crypto.subtle.importKey(\"raw\", password, id, false, usage);\n    result.salt = \"\";\n  }\n  if (options.iv)\n    result.iv = options.iv;\n  else if (\"ivBits\" in algorithm)\n    result.iv = randomBits(_crypto, algorithm.ivBits);\n  return result;\n};\nvar encrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const textBuffer = stringToBuffer(data);\n  const encrypted = await _crypto.subtle.encrypt(\n    { name: algorithms[options.algorithm].name, iv: key.iv },\n    key.key,\n    textBuffer\n  );\n  return { encrypted: new Uint8Array(encrypted), key };\n};\nvar decrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const decrypted = await _crypto.subtle.decrypt(\n    { name: algorithms[options.algorithm].name, iv: key.iv },\n    key.key,\n    typeof data === \"string\" ? stringToBuffer(data) : data\n  );\n  return bufferToString(new Uint8Array(decrypted));\n};\nvar hmacWithPassword = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, { ...options, hmac: true });\n  const textBuffer = stringToBuffer(data);\n  const signed = await _crypto.subtle.sign({ name: \"HMAC\" }, key.key, textBuffer);\n  const digest = base64urlEncode(new Uint8Array(signed));\n  return { digest, salt: key.salt };\n};\nvar normalizePassword = (password) => {\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    return { encryption: password, integrity: password };\n  if (\"secret\" in password)\n    return { id: password.id, encryption: password.secret, integrity: password.secret };\n  return { id: password.id, encryption: password.encryption, integrity: password.integrity };\n};\nvar seal = async (_crypto, object, password, options) => {\n  if (!password)\n    throw Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const objectString = JSON.stringify(object);\n  const pass = normalizePassword(password);\n  const { id = \"\" } = pass;\n  if (id && !/^\\w+$/.test(id))\n    throw new Error(\"Invalid password id\");\n  const { encrypted, key } = await encrypt(_crypto, pass.encryption, opts.encryption, objectString);\n  const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));\n  const iv = base64urlEncode(key.iv);\n  const expiration = opts.ttl ? now + opts.ttl : \"\";\n  const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;\n  const mac = await hmacWithPassword(_crypto, pass.integrity, opts.integrity, macBaseString);\n  const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;\n  return sealed;\n};\nvar fixedTimeComparison = (a, b) => {\n  let mismatch = a.length === b.length ? 0 : 1;\n  if (mismatch)\n    b = a;\n  for (let i = 0; i < a.length; i += 1)\n    mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  return mismatch === 0;\n};\nvar unseal = async (_crypto, sealed, password, options) => {\n  if (!password)\n    throw Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const parts = sealed.split(\"*\");\n  if (parts.length !== 8)\n    throw new Error(\"Incorrect number of sealed components\");\n  const prefix = parts[0];\n  let passwordId = parts[1];\n  const encryptionSalt = parts[2];\n  const encryptionIv = parts[3];\n  const encryptedB64 = parts[4];\n  const expiration = parts[5];\n  const hmacSalt = parts[6];\n  const hmac = parts[7];\n  const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;\n  if (macPrefix !== prefix)\n    throw new Error(\"Wrong mac prefix\");\n  if (expiration) {\n    if (!/^\\d+$/.exec(expiration))\n      throw new Error(\"Invalid expiration\");\n    const exp = parseInt(expiration, 10);\n    if (exp <= now - opts.timestampSkewSec * 1e3)\n      throw new Error(\"Expired seal\");\n  }\n  if (typeof password === \"undefined\" || typeof password === \"string\" && password.length === 0)\n    throw new Error(\"Empty password\");\n  let pass = \"\";\n  passwordId = passwordId || \"default\";\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    pass = password;\n  else if (!(passwordId in password))\n    throw new Error(`Cannot find password: ${passwordId}`);\n  else\n    pass = password[passwordId];\n  pass = normalizePassword(pass);\n  const macOptions = opts.integrity;\n  macOptions.salt = hmacSalt;\n  const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);\n  if (!fixedTimeComparison(mac.digest, hmac))\n    throw new Error(\"Bad hmac value\");\n  const encrypted = base64urlDecode(encryptedB64);\n  const decryptOptions = opts.encryption;\n  decryptOptions.salt = encryptionSalt;\n  decryptOptions.iv = base64urlDecode(encryptionIv);\n  const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);\n  if (decrypted)\n    return JSON.parse(decrypted);\n  return null;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pcm9uLXdlYmNyeXB0by9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0JBQW9CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG9CQUFvQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtFQUErRTtBQUMvRixlQUFlLDBFQUEwRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGVBQWU7QUFDZixDQUFDO0FBQ0Q7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9ELG1CQUFtQiw0Q0FBNEM7QUFDL0QsWUFBWTtBQUNaO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUMsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQkFBMkI7QUFDckU7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzREFBc0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzREFBc0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHdCQUF3QjtBQUM3RTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxhQUFhLEdBQUcsV0FBVztBQUMzRjtBQUNBLG9CQUFvQixjQUFjLEdBQUcsU0FBUyxHQUFHLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxHQUFHLFdBQVcsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxXQUFXO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udC8uL25vZGVfbW9kdWxlcy9pcm9uLXdlYmNyeXB0by9kaXN0L2luZGV4LmpzP2EzY2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BzbWl0aHkrdXRpbC1iYXNlNjRAMi4wLjAvbm9kZV9tb2R1bGVzL0BzbWl0aHkvdXRpbC1iYXNlNjQvZGlzdC1lcy9jb25zdGFudHMuYnJvd3Nlci5qc1xudmFyIGFscGhhYmV0QnlFbmNvZGluZyA9IHt9O1xudmFyIGFscGhhYmV0QnlWYWx1ZSA9IG5ldyBBcnJheSg2NCk7XG5mb3IgKGxldCBpID0gMCwgc3RhcnQgPSBcIkFcIi5jaGFyQ29kZUF0KDApLCBsaW1pdCA9IFwiWlwiLmNoYXJDb2RlQXQoMCk7IGkgKyBzdGFydCA8PSBsaW1pdDsgaSsrKSB7XG4gIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyBzdGFydCk7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tjaGFyXSA9IGk7XG4gIGFscGhhYmV0QnlWYWx1ZVtpXSA9IGNoYXI7XG59XG5mb3IgKGxldCBpID0gMCwgc3RhcnQgPSBcImFcIi5jaGFyQ29kZUF0KDApLCBsaW1pdCA9IFwielwiLmNoYXJDb2RlQXQoMCk7IGkgKyBzdGFydCA8PSBsaW1pdDsgaSsrKSB7XG4gIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyBzdGFydCk7XG4gIGNvbnN0IGluZGV4ID0gaSArIDI2O1xuICBhbHBoYWJldEJ5RW5jb2RpbmdbY2hhcl0gPSBpbmRleDtcbiAgYWxwaGFiZXRCeVZhbHVlW2luZGV4XSA9IGNoYXI7XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2kudG9TdHJpbmcoMTApXSA9IGkgKyA1MjtcbiAgY29uc3QgY2hhciA9IGkudG9TdHJpbmcoMTApO1xuICBjb25zdCBpbmRleCA9IGkgKyA1MjtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2NoYXJdID0gaW5kZXg7XG4gIGFscGhhYmV0QnlWYWx1ZVtpbmRleF0gPSBjaGFyO1xufVxuYWxwaGFiZXRCeUVuY29kaW5nW1wiK1wiXSA9IDYyO1xuYWxwaGFiZXRCeVZhbHVlWzYyXSA9IFwiK1wiO1xuYWxwaGFiZXRCeUVuY29kaW5nW1wiL1wiXSA9IDYzO1xuYWxwaGFiZXRCeVZhbHVlWzYzXSA9IFwiL1wiO1xudmFyIGJpdHNQZXJMZXR0ZXIgPSA2O1xudmFyIGJpdHNQZXJCeXRlID0gODtcbnZhciBtYXhMZXR0ZXJWYWx1ZSA9IDYzO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQHNtaXRoeSt1dGlsLWJhc2U2NEAyLjAuMC9ub2RlX21vZHVsZXMvQHNtaXRoeS91dGlsLWJhc2U2NC9kaXN0LWVzL2Zyb21CYXNlNjQuYnJvd3Nlci5qc1xudmFyIGZyb21CYXNlNjQgPSAoaW5wdXQpID0+IHtcbiAgbGV0IHRvdGFsQnl0ZUxlbmd0aCA9IGlucHV0Lmxlbmd0aCAvIDQgKiAzO1xuICBpZiAoaW5wdXQuc2xpY2UoLTIpID09PSBcIj09XCIpIHtcbiAgICB0b3RhbEJ5dGVMZW5ndGggLT0gMjtcbiAgfSBlbHNlIGlmIChpbnB1dC5zbGljZSgtMSkgPT09IFwiPVwiKSB7XG4gICAgdG90YWxCeXRlTGVuZ3RoLS07XG4gIH1cbiAgY29uc3Qgb3V0ID0gbmV3IEFycmF5QnVmZmVyKHRvdGFsQnl0ZUxlbmd0aCk7XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG91dCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IGJpdExlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IGksIGxpbWl0ID0gaSArIDM7IGogPD0gbGltaXQ7IGorKykge1xuICAgICAgaWYgKGlucHV0W2pdICE9PSBcIj1cIikge1xuICAgICAgICBpZiAoIShpbnB1dFtqXSBpbiBhbHBoYWJldEJ5RW5jb2RpbmcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgJHtpbnB1dFtqXX0gaW4gYmFzZTY0IHN0cmluZy5gKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRzIHw9IGFscGhhYmV0QnlFbmNvZGluZ1tpbnB1dFtqXV0gPDwgKGxpbWl0IC0gaikgKiBiaXRzUGVyTGV0dGVyO1xuICAgICAgICBiaXRMZW5ndGggKz0gYml0c1BlckxldHRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpdHMgPj49IGJpdHNQZXJMZXR0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT2Zmc2V0ID0gaSAvIDQgKiAzO1xuICAgIGJpdHMgPj49IGJpdExlbmd0aCAlIGJpdHNQZXJCeXRlO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBNYXRoLmZsb29yKGJpdExlbmd0aCAvIGJpdHNQZXJCeXRlKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGJ5dGVMZW5ndGg7IGsrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGJ5dGVMZW5ndGggLSBrIC0gMSkgKiBiaXRzUGVyQnl0ZTtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KGNodW5rT2Zmc2V0ICsgaywgKGJpdHMgJiAyNTUgPDwgb2Zmc2V0KSA+PiBvZmZzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkob3V0KTtcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9Ac21pdGh5K3V0aWwtYmFzZTY0QDIuMC4wL25vZGVfbW9kdWxlcy9Ac21pdGh5L3V0aWwtYmFzZTY0L2Rpc3QtZXMvdG9CYXNlNjQuYnJvd3Nlci5qc1xuZnVuY3Rpb24gdG9CYXNlNjQoaW5wdXQpIHtcbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IGJpdExlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IGksIGxpbWl0ID0gTWF0aC5taW4oaSArIDMsIGlucHV0Lmxlbmd0aCk7IGogPCBsaW1pdDsgaisrKSB7XG4gICAgICBiaXRzIHw9IGlucHV0W2pdIDw8IChsaW1pdCAtIGogLSAxKSAqIGJpdHNQZXJCeXRlO1xuICAgICAgYml0TGVuZ3RoICs9IGJpdHNQZXJCeXRlO1xuICAgIH1cbiAgICBjb25zdCBiaXRDbHVzdGVyQ291bnQgPSBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gYml0c1BlckxldHRlcik7XG4gICAgYml0cyA8PD0gYml0Q2x1c3RlckNvdW50ICogYml0c1BlckxldHRlciAtIGJpdExlbmd0aDtcbiAgICBmb3IgKGxldCBrID0gMTsgayA8PSBiaXRDbHVzdGVyQ291bnQ7IGsrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGJpdENsdXN0ZXJDb3VudCAtIGspICogYml0c1BlckxldHRlcjtcbiAgICAgIHN0ciArPSBhbHBoYWJldEJ5VmFsdWVbKGJpdHMgJiBtYXhMZXR0ZXJWYWx1ZSA8PCBvZmZzZXQpID4+IG9mZnNldF07XG4gICAgfVxuICAgIHN0ciArPSBcIj09XCIuc2xpY2UoMCwgNCAtIGJpdENsdXN0ZXJDb3VudCk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3RyaW5nVG9CdWZmZXIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59O1xudmFyIGJ1ZmZlclRvU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xufTtcbnZhciBiYXNlNjR1cmxFbmNvZGUgPSAodmFsdWUpID0+IHRvQmFzZTY0KHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvQnVmZmVyKHZhbHVlKSA6IHZhbHVlKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPS9nLCBcIlwiKTtcbnZhciBiYXNlNjR1cmxEZWNvZGUgPSAodmFsdWUpID0+IGZyb21CYXNlNjQoXG4gIHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpICsgQXJyYXkoKDQgLSB2YWx1ZS5sZW5ndGggJSA0KSAlIDQgKyAxKS5qb2luKFwiPVwiKVxuKTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgZW5jcnlwdGlvbjogeyBzYWx0Qml0czogMjU2LCBhbGdvcml0aG06IFwiYWVzLTI1Ni1jYmNcIiwgaXRlcmF0aW9uczogMSwgbWluUGFzc3dvcmRsZW5ndGg6IDMyIH0sXG4gIGludGVncml0eTogeyBzYWx0Qml0czogMjU2LCBhbGdvcml0aG06IFwic2hhMjU2XCIsIGl0ZXJhdGlvbnM6IDEsIG1pblBhc3N3b3JkbGVuZ3RoOiAzMiB9LFxuICB0dGw6IDAsXG4gIHRpbWVzdGFtcFNrZXdTZWM6IDYwLFxuICBsb2NhbHRpbWVPZmZzZXRNc2VjOiAwXG59O1xudmFyIGNsb25lID0gKG9wdGlvbnMpID0+ICh7XG4gIC4uLm9wdGlvbnMsXG4gIGVuY3J5cHRpb246IHsgLi4ub3B0aW9ucy5lbmNyeXB0aW9uIH0sXG4gIGludGVncml0eTogeyAuLi5vcHRpb25zLmludGVncml0eSB9XG59KTtcbnZhciBhbGdvcml0aG1zID0ge1xuICBcImFlcy0xMjgtY3RyXCI6IHsga2V5Qml0czogMTI4LCBpdkJpdHM6IDEyOCwgbmFtZTogXCJBRVMtQ1RSXCIgfSxcbiAgXCJhZXMtMjU2LWNiY1wiOiB7IGtleUJpdHM6IDI1NiwgaXZCaXRzOiAxMjgsIG5hbWU6IFwiQUVTLUNCQ1wiIH0sXG4gIHNoYTI1NjogeyBrZXlCaXRzOiAyNTYsIG5hbWU6IFwiU0hBLTI1NlwiIH1cbn07XG52YXIgbWFjRm9ybWF0VmVyc2lvbiA9IFwiMlwiO1xudmFyIG1hY1ByZWZpeCA9IGBGZTI2LiR7bWFjRm9ybWF0VmVyc2lvbn1gO1xudmFyIHJhbmRvbUJ5dGVzID0gKF9jcnlwdG8sIHNpemUpID0+IHtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xudmFyIHJhbmRvbUJpdHMgPSAoX2NyeXB0bywgYml0cykgPT4ge1xuICBpZiAoYml0cyA8IDEpXG4gICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJhbmRvbSBiaXRzIGNvdW50XCIpO1xuICBjb25zdCBieXRlcyA9IE1hdGguY2VpbChiaXRzIC8gOCk7XG4gIHJldHVybiByYW5kb21CeXRlcyhfY3J5cHRvLCBieXRlcyk7XG59O1xudmFyIHBia2RmMiA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5TGVuZ3RoLCBoYXNoKSA9PiB7XG4gIGNvbnN0IHBhc3N3b3JkQnVmZmVyID0gc3RyaW5nVG9CdWZmZXIocGFzc3dvcmQpO1xuICBjb25zdCBpbXBvcnRlZEtleSA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBwYXNzd29yZEJ1ZmZlciwgXCJQQktERjJcIiwgZmFsc2UsIFtcbiAgICBcImRlcml2ZUJpdHNcIlxuICBdKTtcbiAgY29uc3Qgc2FsdEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKHNhbHQpO1xuICBjb25zdCBwYXJhbXMgPSB7IG5hbWU6IFwiUEJLREYyXCIsIGhhc2gsIHNhbHQ6IHNhbHRCdWZmZXIsIGl0ZXJhdGlvbnMgfTtcbiAgY29uc3QgZGVyaXZhdGlvbiA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMocGFyYW1zLCBpbXBvcnRlZEtleSwga2V5TGVuZ3RoICogOCk7XG4gIHJldHVybiBkZXJpdmF0aW9uO1xufTtcbnZhciBnZW5lcmF0ZUtleSA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucykgPT4ge1xuICB2YXIgX2E7XG4gIGlmICghKHBhc3N3b3JkID09IG51bGwgPyB2b2lkIDAgOiBwYXNzd29yZC5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHBhc3N3b3JkXCIpO1xuICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBvcHRpb25zXCIpO1xuICBpZiAoIShvcHRpb25zLmFsZ29yaXRobSBpbiBhbGdvcml0aG1zKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWxnb3JpdGhtOiAke29wdGlvbnMuYWxnb3JpdGhtfWApO1xuICBjb25zdCBhbGdvcml0aG0gPSBhbGdvcml0aG1zW29wdGlvbnMuYWxnb3JpdGhtXTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGhtYWMgPSAoX2EgPSBvcHRpb25zLmhtYWMpICE9IG51bGwgPyBfYSA6IGZhbHNlO1xuICBjb25zdCBpZCA9IGhtYWMgPyB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBhbGdvcml0aG0ubmFtZSB9IDogeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9O1xuICBjb25zdCB1c2FnZSA9IGhtYWMgPyBbXCJzaWduXCIsIFwidmVyaWZ5XCJdIDogW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIl07XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgb3B0aW9ucy5taW5QYXNzd29yZGxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBhc3N3b3JkIHN0cmluZyB0b28gc2hvcnQgKG1pbiAke29wdGlvbnMubWluUGFzc3dvcmRsZW5ndGh9IGNoYXJhY3RlcnMgcmVxdWlyZWQpYFxuICAgICAgKTtcbiAgICBsZXQgeyBzYWx0ID0gXCJcIiB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXNhbHQpIHtcbiAgICAgIGNvbnN0IHsgc2FsdEJpdHMgPSAwIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKCFzYWx0Qml0cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzYWx0IGFuZCBzYWx0Qml0cyBvcHRpb25zXCIpO1xuICAgICAgY29uc3QgcmFuZG9tU2FsdCA9IHJhbmRvbUJpdHMoX2NyeXB0bywgc2FsdEJpdHMpO1xuICAgICAgc2FsdCA9IFsuLi5uZXcgVWludDhBcnJheShyYW5kb21TYWx0KV0ubWFwKCh4KSA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBhd2FpdCBwYmtkZjIoXG4gICAgICBfY3J5cHRvLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBzYWx0LFxuICAgICAgb3B0aW9ucy5pdGVyYXRpb25zLFxuICAgICAgYWxnb3JpdGhtLmtleUJpdHMgLyA4LFxuICAgICAgXCJTSEEtMVwiXG4gICAgKTtcbiAgICBjb25zdCBpbXBvcnRlZEVuY3J5cHRpb25LZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgICBcInJhd1wiLFxuICAgICAgZGVyaXZlZEtleSxcbiAgICAgIGlkLFxuICAgICAgZmFsc2UsXG4gICAgICB1c2FnZVxuICAgICk7XG4gICAgcmVzdWx0LmtleSA9IGltcG9ydGVkRW5jcnlwdGlvbktleTtcbiAgICByZXN1bHQuc2FsdCA9IHNhbHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IGFsZ29yaXRobS5rZXlCaXRzIC8gOClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBidWZmZXIgKHBhc3N3b3JkKSB0b28gc21hbGxcIik7XG4gICAgcmVzdWx0LmtleSA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBwYXNzd29yZCwgaWQsIGZhbHNlLCB1c2FnZSk7XG4gICAgcmVzdWx0LnNhbHQgPSBcIlwiO1xuICB9XG4gIGlmIChvcHRpb25zLml2KVxuICAgIHJlc3VsdC5pdiA9IG9wdGlvbnMuaXY7XG4gIGVsc2UgaWYgKFwiaXZCaXRzXCIgaW4gYWxnb3JpdGhtKVxuICAgIHJlc3VsdC5pdiA9IHJhbmRvbUJpdHMoX2NyeXB0bywgYWxnb3JpdGhtLml2Qml0cyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGVuY3J5cHQgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMsIGRhdGEpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2VuZXJhdGVLZXkoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gc3RyaW5nVG9CdWZmZXIoZGF0YSk7XG4gIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmVuY3J5cHQoXG4gICAgeyBuYW1lOiBhbGdvcml0aG1zW29wdGlvbnMuYWxnb3JpdGhtXS5uYW1lLCBpdjoga2V5Lml2IH0sXG4gICAga2V5LmtleSxcbiAgICB0ZXh0QnVmZmVyXG4gICk7XG4gIHJldHVybiB7IGVuY3J5cHRlZDogbmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkKSwga2V5IH07XG59O1xudmFyIGRlY3J5cHQgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMsIGRhdGEpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2VuZXJhdGVLZXkoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgIHsgbmFtZTogYWxnb3JpdGhtc1tvcHRpb25zLmFsZ29yaXRobV0ubmFtZSwgaXY6IGtleS5pdiB9LFxuICAgIGtleS5rZXksXG4gICAgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0J1ZmZlcihkYXRhKSA6IGRhdGFcbiAgKTtcbiAgcmV0dXJuIGJ1ZmZlclRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZCkpO1xufTtcbnZhciBobWFjV2l0aFBhc3N3b3JkID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCB7IC4uLm9wdGlvbnMsIGhtYWM6IHRydWUgfSk7XG4gIGNvbnN0IHRleHRCdWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihkYXRhKTtcbiAgY29uc3Qgc2lnbmVkID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuc2lnbih7IG5hbWU6IFwiSE1BQ1wiIH0sIGtleS5rZXksIHRleHRCdWZmZXIpO1xuICBjb25zdCBkaWdlc3QgPSBiYXNlNjR1cmxFbmNvZGUobmV3IFVpbnQ4QXJyYXkoc2lnbmVkKSk7XG4gIHJldHVybiB7IGRpZ2VzdCwgc2FsdDoga2V5LnNhbHQgfTtcbn07XG52YXIgbm9ybWFsaXplUGFzc3dvcmQgPSAocGFzc3dvcmQpID0+IHtcbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIiB8fCBwYXNzd29yZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgcmV0dXJuIHsgZW5jcnlwdGlvbjogcGFzc3dvcmQsIGludGVncml0eTogcGFzc3dvcmQgfTtcbiAgaWYgKFwic2VjcmV0XCIgaW4gcGFzc3dvcmQpXG4gICAgcmV0dXJuIHsgaWQ6IHBhc3N3b3JkLmlkLCBlbmNyeXB0aW9uOiBwYXNzd29yZC5zZWNyZXQsIGludGVncml0eTogcGFzc3dvcmQuc2VjcmV0IH07XG4gIHJldHVybiB7IGlkOiBwYXNzd29yZC5pZCwgZW5jcnlwdGlvbjogcGFzc3dvcmQuZW5jcnlwdGlvbiwgaW50ZWdyaXR5OiBwYXNzd29yZC5pbnRlZ3JpdHkgfTtcbn07XG52YXIgc2VhbCA9IGFzeW5jIChfY3J5cHRvLCBvYmplY3QsIHBhc3N3b3JkLCBvcHRpb25zKSA9PiB7XG4gIGlmICghcGFzc3dvcmQpXG4gICAgdGhyb3cgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgY29uc3Qgb3B0cyA9IGNsb25lKG9wdGlvbnMpO1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKTtcbiAgY29uc3Qgb2JqZWN0U3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgY29uc3QgcGFzcyA9IG5vcm1hbGl6ZVBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgY29uc3QgeyBpZCA9IFwiXCIgfSA9IHBhc3M7XG4gIGlmIChpZCAmJiAhL15cXHcrJC8udGVzdChpZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXNzd29yZCBpZFwiKTtcbiAgY29uc3QgeyBlbmNyeXB0ZWQsIGtleSB9ID0gYXdhaXQgZW5jcnlwdChfY3J5cHRvLCBwYXNzLmVuY3J5cHRpb24sIG9wdHMuZW5jcnlwdGlvbiwgb2JqZWN0U3RyaW5nKTtcbiAgY29uc3QgZW5jcnlwdGVkQjY0ID0gYmFzZTY0dXJsRW5jb2RlKG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCkpO1xuICBjb25zdCBpdiA9IGJhc2U2NHVybEVuY29kZShrZXkuaXYpO1xuICBjb25zdCBleHBpcmF0aW9uID0gb3B0cy50dGwgPyBub3cgKyBvcHRzLnR0bCA6IFwiXCI7XG4gIGNvbnN0IG1hY0Jhc2VTdHJpbmcgPSBgJHttYWNQcmVmaXh9KiR7aWR9KiR7a2V5LnNhbHR9KiR7aXZ9KiR7ZW5jcnlwdGVkQjY0fSoke2V4cGlyYXRpb259YDtcbiAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1dpdGhQYXNzd29yZChfY3J5cHRvLCBwYXNzLmludGVncml0eSwgb3B0cy5pbnRlZ3JpdHksIG1hY0Jhc2VTdHJpbmcpO1xuICBjb25zdCBzZWFsZWQgPSBgJHttYWNCYXNlU3RyaW5nfSoke21hYy5zYWx0fSoke21hYy5kaWdlc3R9YDtcbiAgcmV0dXJuIHNlYWxlZDtcbn07XG52YXIgZml4ZWRUaW1lQ29tcGFyaXNvbiA9IChhLCBiKSA9PiB7XG4gIGxldCBtaXNtYXRjaCA9IGEubGVuZ3RoID09PSBiLmxlbmd0aCA/IDAgOiAxO1xuICBpZiAobWlzbWF0Y2gpXG4gICAgYiA9IGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSlcbiAgICBtaXNtYXRjaCB8PSBhLmNoYXJDb2RlQXQoaSkgXiBiLmNoYXJDb2RlQXQoaSk7XG4gIHJldHVybiBtaXNtYXRjaCA9PT0gMDtcbn07XG52YXIgdW5zZWFsID0gYXN5bmMgKF9jcnlwdG8sIHNlYWxlZCwgcGFzc3dvcmQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFwYXNzd29yZClcbiAgICB0aHJvdyBFcnJvcihcIkVtcHR5IHBhc3N3b3JkXCIpO1xuICBjb25zdCBvcHRzID0gY2xvbmUob3B0aW9ucyk7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCkgKyAob3B0cy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApO1xuICBjb25zdCBwYXJ0cyA9IHNlYWxlZC5zcGxpdChcIipcIik7XG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IG51bWJlciBvZiBzZWFsZWQgY29tcG9uZW50c1wiKTtcbiAgY29uc3QgcHJlZml4ID0gcGFydHNbMF07XG4gIGxldCBwYXNzd29yZElkID0gcGFydHNbMV07XG4gIGNvbnN0IGVuY3J5cHRpb25TYWx0ID0gcGFydHNbMl07XG4gIGNvbnN0IGVuY3J5cHRpb25JdiA9IHBhcnRzWzNdO1xuICBjb25zdCBlbmNyeXB0ZWRCNjQgPSBwYXJ0c1s0XTtcbiAgY29uc3QgZXhwaXJhdGlvbiA9IHBhcnRzWzVdO1xuICBjb25zdCBobWFjU2FsdCA9IHBhcnRzWzZdO1xuICBjb25zdCBobWFjID0gcGFydHNbN107XG4gIGNvbnN0IG1hY0Jhc2VTdHJpbmcgPSBgJHtwcmVmaXh9KiR7cGFzc3dvcmRJZH0qJHtlbmNyeXB0aW9uU2FsdH0qJHtlbmNyeXB0aW9uSXZ9KiR7ZW5jcnlwdGVkQjY0fSoke2V4cGlyYXRpb259YDtcbiAgaWYgKG1hY1ByZWZpeCAhPT0gcHJlZml4KVxuICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIG1hYyBwcmVmaXhcIik7XG4gIGlmIChleHBpcmF0aW9uKSB7XG4gICAgaWYgKCEvXlxcZCskLy5leGVjKGV4cGlyYXRpb24pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleHBpcmF0aW9uXCIpO1xuICAgIGNvbnN0IGV4cCA9IHBhcnNlSW50KGV4cGlyYXRpb24sIDEwKTtcbiAgICBpZiAoZXhwIDw9IG5vdyAtIG9wdHMudGltZXN0YW1wU2tld1NlYyAqIDFlMylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGlyZWQgc2VhbFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIiAmJiBwYXNzd29yZC5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgcGFzc3dvcmRcIik7XG4gIGxldCBwYXNzID0gXCJcIjtcbiAgcGFzc3dvcmRJZCA9IHBhc3N3b3JkSWQgfHwgXCJkZWZhdWx0XCI7XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgfHwgcGFzc3dvcmQgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHBhc3MgPSBwYXNzd29yZDtcbiAgZWxzZSBpZiAoIShwYXNzd29yZElkIGluIHBhc3N3b3JkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIHBhc3N3b3JkOiAke3Bhc3N3b3JkSWR9YCk7XG4gIGVsc2VcbiAgICBwYXNzID0gcGFzc3dvcmRbcGFzc3dvcmRJZF07XG4gIHBhc3MgPSBub3JtYWxpemVQYXNzd29yZChwYXNzKTtcbiAgY29uc3QgbWFjT3B0aW9ucyA9IG9wdHMuaW50ZWdyaXR5O1xuICBtYWNPcHRpb25zLnNhbHQgPSBobWFjU2FsdDtcbiAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1dpdGhQYXNzd29yZChfY3J5cHRvLCBwYXNzLmludGVncml0eSwgbWFjT3B0aW9ucywgbWFjQmFzZVN0cmluZyk7XG4gIGlmICghZml4ZWRUaW1lQ29tcGFyaXNvbihtYWMuZGlnZXN0LCBobWFjKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgaG1hYyB2YWx1ZVwiKTtcbiAgY29uc3QgZW5jcnlwdGVkID0gYmFzZTY0dXJsRGVjb2RlKGVuY3J5cHRlZEI2NCk7XG4gIGNvbnN0IGRlY3J5cHRPcHRpb25zID0gb3B0cy5lbmNyeXB0aW9uO1xuICBkZWNyeXB0T3B0aW9ucy5zYWx0ID0gZW5jcnlwdGlvblNhbHQ7XG4gIGRlY3J5cHRPcHRpb25zLml2ID0gYmFzZTY0dXJsRGVjb2RlKGVuY3J5cHRpb25Jdik7XG4gIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGRlY3J5cHQoX2NyeXB0bywgcGFzcy5lbmNyeXB0aW9uLCBkZWNyeXB0T3B0aW9ucywgZW5jcnlwdGVkKTtcbiAgaWYgKGRlY3J5cHRlZClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNyeXB0ZWQpO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCB7IGFsZ29yaXRobXMsIGJhc2U2NHVybERlY29kZSwgYmFzZTY0dXJsRW5jb2RlLCBidWZmZXJUb1N0cmluZywgY2xvbmUsIGRlY3J5cHQsIGRlZmF1bHRzLCBlbmNyeXB0LCBnZW5lcmF0ZUtleSwgaG1hY1dpdGhQYXNzd29yZCwgbWFjRm9ybWF0VmVyc2lvbiwgbWFjUHJlZml4LCByYW5kb21CaXRzLCBzZWFsLCBzdHJpbmdUb0J1ZmZlciwgdW5zZWFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/iron-webcrypto/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/iron-webcrypto/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/iron-webcrypto/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   algorithms: () => (/* binding */ algorithms),\n/* harmony export */   base64urlDecode: () => (/* binding */ base64urlDecode),\n/* harmony export */   base64urlEncode: () => (/* binding */ base64urlEncode),\n/* harmony export */   bufferToString: () => (/* binding */ bufferToString),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   hmacWithPassword: () => (/* binding */ hmacWithPassword),\n/* harmony export */   macFormatVersion: () => (/* binding */ macFormatVersion),\n/* harmony export */   macPrefix: () => (/* binding */ macPrefix),\n/* harmony export */   randomBits: () => (/* binding */ randomBits),\n/* harmony export */   seal: () => (/* binding */ seal),\n/* harmony export */   stringToBuffer: () => (/* binding */ stringToBuffer),\n/* harmony export */   unseal: () => (/* binding */ unseal)\n/* harmony export */ });\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/constants.browser.js\nvar alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js\nvar fromBase64 = (input) => {\n  let totalByteLength = input.length / 4 * 3;\n  if (input.slice(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.slice(-1) === \"=\") {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        if (!(input[j] in alphabetByEncoding)) {\n          throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n        }\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n    const chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n  return new Uint8Array(out);\n};\n\n// node_modules/.pnpm/@smithy+util-base64@2.0.0/node_modules/@smithy/util-base64/dist-es/toBase64.browser.js\nfunction toBase64(input) {\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n  return str;\n}\n\n// src/index.ts\nvar stringToBuffer = (value) => {\n  return new TextEncoder().encode(value);\n};\nvar bufferToString = (value) => {\n  return new TextDecoder().decode(value);\n};\nvar base64urlEncode = (value) => toBase64(typeof value === \"string\" ? stringToBuffer(value) : value).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\nvar base64urlDecode = (value) => fromBase64(\n  value.replace(/-/g, \"+\").replace(/_/g, \"/\") + Array((4 - value.length % 4) % 4 + 1).join(\"=\")\n);\nvar defaults = {\n  encryption: { saltBits: 256, algorithm: \"aes-256-cbc\", iterations: 1, minPasswordlength: 32 },\n  integrity: { saltBits: 256, algorithm: \"sha256\", iterations: 1, minPasswordlength: 32 },\n  ttl: 0,\n  timestampSkewSec: 60,\n  localtimeOffsetMsec: 0\n};\nvar clone = (options) => ({\n  ...options,\n  encryption: { ...options.encryption },\n  integrity: { ...options.integrity }\n});\nvar algorithms = {\n  \"aes-128-ctr\": { keyBits: 128, ivBits: 128, name: \"AES-CTR\" },\n  \"aes-256-cbc\": { keyBits: 256, ivBits: 128, name: \"AES-CBC\" },\n  sha256: { keyBits: 256, name: \"SHA-256\" }\n};\nvar macFormatVersion = \"2\";\nvar macPrefix = `Fe26.${macFormatVersion}`;\nvar randomBytes = (_crypto, size) => {\n  const bytes = new Uint8Array(size);\n  _crypto.getRandomValues(bytes);\n  return bytes;\n};\nvar randomBits = (_crypto, bits) => {\n  if (bits < 1)\n    throw Error(\"Invalid random bits count\");\n  const bytes = Math.ceil(bits / 8);\n  return randomBytes(_crypto, bytes);\n};\nvar pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash) => {\n  const passwordBuffer = stringToBuffer(password);\n  const importedKey = await _crypto.subtle.importKey(\"raw\", passwordBuffer, \"PBKDF2\", false, [\n    \"deriveBits\"\n  ]);\n  const saltBuffer = stringToBuffer(salt);\n  const params = { name: \"PBKDF2\", hash, salt: saltBuffer, iterations };\n  const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);\n  return derivation;\n};\nvar generateKey = async (_crypto, password, options) => {\n  var _a;\n  if (!(password == null ? void 0 : password.length))\n    throw new Error(\"Empty password\");\n  if (options == null || typeof options !== \"object\")\n    throw new Error(\"Bad options\");\n  if (!(options.algorithm in algorithms))\n    throw new Error(`Unknown algorithm: ${options.algorithm}`);\n  const algorithm = algorithms[options.algorithm];\n  const result = {};\n  const hmac = (_a = options.hmac) != null ? _a : false;\n  const id = hmac ? { name: \"HMAC\", hash: algorithm.name } : { name: algorithm.name };\n  const usage = hmac ? [\"sign\", \"verify\"] : [\"encrypt\", \"decrypt\"];\n  if (typeof password === \"string\") {\n    if (password.length < options.minPasswordlength)\n      throw new Error(\n        `Password string too short (min ${options.minPasswordlength} characters required)`\n      );\n    let { salt = \"\" } = options;\n    if (!salt) {\n      const { saltBits = 0 } = options;\n      if (!saltBits)\n        throw new Error(\"Missing salt and saltBits options\");\n      const randomSalt = randomBits(_crypto, saltBits);\n      salt = [...new Uint8Array(randomSalt)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n    const derivedKey = await pbkdf2(\n      _crypto,\n      password,\n      salt,\n      options.iterations,\n      algorithm.keyBits / 8,\n      \"SHA-1\"\n    );\n    const importedEncryptionKey = await _crypto.subtle.importKey(\n      \"raw\",\n      derivedKey,\n      id,\n      false,\n      usage\n    );\n    result.key = importedEncryptionKey;\n    result.salt = salt;\n  } else {\n    if (password.length < algorithm.keyBits / 8)\n      throw new Error(\"Key buffer (password) too small\");\n    result.key = await _crypto.subtle.importKey(\"raw\", password, id, false, usage);\n    result.salt = \"\";\n  }\n  if (options.iv)\n    result.iv = options.iv;\n  else if (\"ivBits\" in algorithm)\n    result.iv = randomBits(_crypto, algorithm.ivBits);\n  return result;\n};\nvar encrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const textBuffer = stringToBuffer(data);\n  const encrypted = await _crypto.subtle.encrypt(\n    { name: algorithms[options.algorithm].name, iv: key.iv },\n    key.key,\n    textBuffer\n  );\n  return { encrypted: new Uint8Array(encrypted), key };\n};\nvar decrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const decrypted = await _crypto.subtle.decrypt(\n    { name: algorithms[options.algorithm].name, iv: key.iv },\n    key.key,\n    typeof data === \"string\" ? stringToBuffer(data) : data\n  );\n  return bufferToString(new Uint8Array(decrypted));\n};\nvar hmacWithPassword = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, { ...options, hmac: true });\n  const textBuffer = stringToBuffer(data);\n  const signed = await _crypto.subtle.sign({ name: \"HMAC\" }, key.key, textBuffer);\n  const digest = base64urlEncode(new Uint8Array(signed));\n  return { digest, salt: key.salt };\n};\nvar normalizePassword = (password) => {\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    return { encryption: password, integrity: password };\n  if (\"secret\" in password)\n    return { id: password.id, encryption: password.secret, integrity: password.secret };\n  return { id: password.id, encryption: password.encryption, integrity: password.integrity };\n};\nvar seal = async (_crypto, object, password, options) => {\n  if (!password)\n    throw Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const objectString = JSON.stringify(object);\n  const pass = normalizePassword(password);\n  const { id = \"\" } = pass;\n  if (id && !/^\\w+$/.test(id))\n    throw new Error(\"Invalid password id\");\n  const { encrypted, key } = await encrypt(_crypto, pass.encryption, opts.encryption, objectString);\n  const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));\n  const iv = base64urlEncode(key.iv);\n  const expiration = opts.ttl ? now + opts.ttl : \"\";\n  const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;\n  const mac = await hmacWithPassword(_crypto, pass.integrity, opts.integrity, macBaseString);\n  const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;\n  return sealed;\n};\nvar fixedTimeComparison = (a, b) => {\n  let mismatch = a.length === b.length ? 0 : 1;\n  if (mismatch)\n    b = a;\n  for (let i = 0; i < a.length; i += 1)\n    mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  return mismatch === 0;\n};\nvar unseal = async (_crypto, sealed, password, options) => {\n  if (!password)\n    throw Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const parts = sealed.split(\"*\");\n  if (parts.length !== 8)\n    throw new Error(\"Incorrect number of sealed components\");\n  const prefix = parts[0];\n  let passwordId = parts[1];\n  const encryptionSalt = parts[2];\n  const encryptionIv = parts[3];\n  const encryptedB64 = parts[4];\n  const expiration = parts[5];\n  const hmacSalt = parts[6];\n  const hmac = parts[7];\n  const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;\n  if (macPrefix !== prefix)\n    throw new Error(\"Wrong mac prefix\");\n  if (expiration) {\n    if (!/^\\d+$/.exec(expiration))\n      throw new Error(\"Invalid expiration\");\n    const exp = parseInt(expiration, 10);\n    if (exp <= now - opts.timestampSkewSec * 1e3)\n      throw new Error(\"Expired seal\");\n  }\n  if (typeof password === \"undefined\" || typeof password === \"string\" && password.length === 0)\n    throw new Error(\"Empty password\");\n  let pass = \"\";\n  passwordId = passwordId || \"default\";\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    pass = password;\n  else if (!(passwordId in password))\n    throw new Error(`Cannot find password: ${passwordId}`);\n  else\n    pass = password[passwordId];\n  pass = normalizePassword(pass);\n  const macOptions = opts.integrity;\n  macOptions.salt = hmacSalt;\n  const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);\n  if (!fixedTimeComparison(mac.digest, hmac))\n    throw new Error(\"Bad hmac value\");\n  const encrypted = base64urlDecode(encryptedB64);\n  const decryptOptions = opts.encryption;\n  decryptOptions.salt = encryptionSalt;\n  decryptOptions.iv = base64urlDecode(encryptionIv);\n  const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);\n  if (decrypted)\n    return JSON.parse(decrypted);\n  return null;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXJvbi13ZWJjcnlwdG8vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG9CQUFvQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvQkFBb0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrRUFBK0U7QUFDL0YsZUFBZSwwRUFBMEU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxlQUFlO0FBQ2YsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRCxtQkFBbUIsNENBQTRDO0FBQy9ELFlBQVk7QUFDWjtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDLElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0RBQXNEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0RBQXNEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx3QkFBd0I7QUFDN0U7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsYUFBYSxHQUFHLFdBQVc7QUFDM0Y7QUFDQSxvQkFBb0IsY0FBYyxHQUFHLFNBQVMsR0FBRyxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sR0FBRyxXQUFXLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsV0FBVztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnQvLi9ub2RlX21vZHVsZXMvaXJvbi13ZWJjcnlwdG8vZGlzdC9pbmRleC5qcz8zYjJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9Ac21pdGh5K3V0aWwtYmFzZTY0QDIuMC4wL25vZGVfbW9kdWxlcy9Ac21pdGh5L3V0aWwtYmFzZTY0L2Rpc3QtZXMvY29uc3RhbnRzLmJyb3dzZXIuanNcbnZhciBhbHBoYWJldEJ5RW5jb2RpbmcgPSB7fTtcbnZhciBhbHBoYWJldEJ5VmFsdWUgPSBuZXcgQXJyYXkoNjQpO1xuZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gXCJBXCIuY2hhckNvZGVBdCgwKSwgbGltaXQgPSBcIlpcIi5jaGFyQ29kZUF0KDApOyBpICsgc3RhcnQgPD0gbGltaXQ7IGkrKykge1xuICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgc3RhcnQpO1xuICBhbHBoYWJldEJ5RW5jb2RpbmdbY2hhcl0gPSBpO1xuICBhbHBoYWJldEJ5VmFsdWVbaV0gPSBjaGFyO1xufVxuZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gXCJhXCIuY2hhckNvZGVBdCgwKSwgbGltaXQgPSBcInpcIi5jaGFyQ29kZUF0KDApOyBpICsgc3RhcnQgPD0gbGltaXQ7IGkrKykge1xuICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgc3RhcnQpO1xuICBjb25zdCBpbmRleCA9IGkgKyAyNjtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2NoYXJdID0gaW5kZXg7XG4gIGFscGhhYmV0QnlWYWx1ZVtpbmRleF0gPSBjaGFyO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tpLnRvU3RyaW5nKDEwKV0gPSBpICsgNTI7XG4gIGNvbnN0IGNoYXIgPSBpLnRvU3RyaW5nKDEwKTtcbiAgY29uc3QgaW5kZXggPSBpICsgNTI7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tjaGFyXSA9IGluZGV4O1xuICBhbHBoYWJldEJ5VmFsdWVbaW5kZXhdID0gY2hhcjtcbn1cbmFscGhhYmV0QnlFbmNvZGluZ1tcIitcIl0gPSA2MjtcbmFscGhhYmV0QnlWYWx1ZVs2Ml0gPSBcIitcIjtcbmFscGhhYmV0QnlFbmNvZGluZ1tcIi9cIl0gPSA2MztcbmFscGhhYmV0QnlWYWx1ZVs2M10gPSBcIi9cIjtcbnZhciBiaXRzUGVyTGV0dGVyID0gNjtcbnZhciBiaXRzUGVyQnl0ZSA9IDg7XG52YXIgbWF4TGV0dGVyVmFsdWUgPSA2MztcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BzbWl0aHkrdXRpbC1iYXNlNjRAMi4wLjAvbm9kZV9tb2R1bGVzL0BzbWl0aHkvdXRpbC1iYXNlNjQvZGlzdC1lcy9mcm9tQmFzZTY0LmJyb3dzZXIuanNcbnZhciBmcm9tQmFzZTY0ID0gKGlucHV0KSA9PiB7XG4gIGxldCB0b3RhbEJ5dGVMZW5ndGggPSBpbnB1dC5sZW5ndGggLyA0ICogMztcbiAgaWYgKGlucHV0LnNsaWNlKC0yKSA9PT0gXCI9PVwiKSB7XG4gICAgdG90YWxCeXRlTGVuZ3RoIC09IDI7XG4gIH0gZWxzZSBpZiAoaW5wdXQuc2xpY2UoLTEpID09PSBcIj1cIikge1xuICAgIHRvdGFsQnl0ZUxlbmd0aC0tO1xuICB9XG4gIGNvbnN0IG91dCA9IG5ldyBBcnJheUJ1ZmZlcih0b3RhbEJ5dGVMZW5ndGgpO1xuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGxldCBiaXRMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGogPSBpLCBsaW1pdCA9IGkgKyAzOyBqIDw9IGxpbWl0OyBqKyspIHtcbiAgICAgIGlmIChpbnB1dFtqXSAhPT0gXCI9XCIpIHtcbiAgICAgICAgaWYgKCEoaW5wdXRbal0gaW4gYWxwaGFiZXRCeUVuY29kaW5nKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyICR7aW5wdXRbal19IGluIGJhc2U2NCBzdHJpbmcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYml0cyB8PSBhbHBoYWJldEJ5RW5jb2RpbmdbaW5wdXRbal1dIDw8IChsaW1pdCAtIGopICogYml0c1BlckxldHRlcjtcbiAgICAgICAgYml0TGVuZ3RoICs9IGJpdHNQZXJMZXR0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRzID4+PSBiaXRzUGVyTGV0dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaHVua09mZnNldCA9IGkgLyA0ICogMztcbiAgICBiaXRzID4+PSBiaXRMZW5ndGggJSBiaXRzUGVyQnl0ZTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gTWF0aC5mbG9vcihiaXRMZW5ndGggLyBiaXRzUGVyQnl0ZSk7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBieXRlTGVuZ3RoOyBrKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChieXRlTGVuZ3RoIC0gayAtIDEpICogYml0c1BlckJ5dGU7XG4gICAgICBkYXRhVmlldy5zZXRVaW50OChjaHVua09mZnNldCArIGssIChiaXRzICYgMjU1IDw8IG9mZnNldCkgPj4gb2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG91dCk7XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQHNtaXRoeSt1dGlsLWJhc2U2NEAyLjAuMC9ub2RlX21vZHVsZXMvQHNtaXRoeS91dGlsLWJhc2U2NC9kaXN0LWVzL3RvQmFzZTY0LmJyb3dzZXIuanNcbmZ1bmN0aW9uIHRvQmFzZTY0KGlucHV0KSB7XG4gIGxldCBzdHIgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGxldCBiaXRMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGogPSBpLCBsaW1pdCA9IE1hdGgubWluKGkgKyAzLCBpbnB1dC5sZW5ndGgpOyBqIDwgbGltaXQ7IGorKykge1xuICAgICAgYml0cyB8PSBpbnB1dFtqXSA8PCAobGltaXQgLSBqIC0gMSkgKiBiaXRzUGVyQnl0ZTtcbiAgICAgIGJpdExlbmd0aCArPSBiaXRzUGVyQnl0ZTtcbiAgICB9XG4gICAgY29uc3QgYml0Q2x1c3RlckNvdW50ID0gTWF0aC5jZWlsKGJpdExlbmd0aCAvIGJpdHNQZXJMZXR0ZXIpO1xuICAgIGJpdHMgPDw9IGJpdENsdXN0ZXJDb3VudCAqIGJpdHNQZXJMZXR0ZXIgLSBiaXRMZW5ndGg7XG4gICAgZm9yIChsZXQgayA9IDE7IGsgPD0gYml0Q2x1c3RlckNvdW50OyBrKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChiaXRDbHVzdGVyQ291bnQgLSBrKSAqIGJpdHNQZXJMZXR0ZXI7XG4gICAgICBzdHIgKz0gYWxwaGFiZXRCeVZhbHVlWyhiaXRzICYgbWF4TGV0dGVyVmFsdWUgPDwgb2Zmc2V0KSA+PiBvZmZzZXRdO1xuICAgIH1cbiAgICBzdHIgKz0gXCI9PVwiLnNsaWNlKDAsIDQgLSBiaXRDbHVzdGVyQ291bnQpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHN0cmluZ1RvQnVmZmVyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufTtcbnZhciBidWZmZXJUb1N0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbn07XG52YXIgYmFzZTY0dXJsRW5jb2RlID0gKHZhbHVlKSA9PiB0b0Jhc2U2NCh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0J1ZmZlcih2YWx1ZSkgOiB2YWx1ZSkucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0vZywgXCJcIik7XG52YXIgYmFzZTY0dXJsRGVjb2RlID0gKHZhbHVlKSA9PiBmcm9tQmFzZTY0KFxuICB2YWx1ZS5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKSArIEFycmF5KCg0IC0gdmFsdWUubGVuZ3RoICUgNCkgJSA0ICsgMSkuam9pbihcIj1cIilcbik7XG52YXIgZGVmYXVsdHMgPSB7XG4gIGVuY3J5cHRpb246IHsgc2FsdEJpdHM6IDI1NiwgYWxnb3JpdGhtOiBcImFlcy0yNTYtY2JjXCIsIGl0ZXJhdGlvbnM6IDEsIG1pblBhc3N3b3JkbGVuZ3RoOiAzMiB9LFxuICBpbnRlZ3JpdHk6IHsgc2FsdEJpdHM6IDI1NiwgYWxnb3JpdGhtOiBcInNoYTI1NlwiLCBpdGVyYXRpb25zOiAxLCBtaW5QYXNzd29yZGxlbmd0aDogMzIgfSxcbiAgdHRsOiAwLFxuICB0aW1lc3RhbXBTa2V3U2VjOiA2MCxcbiAgbG9jYWx0aW1lT2Zmc2V0TXNlYzogMFxufTtcbnZhciBjbG9uZSA9IChvcHRpb25zKSA9PiAoe1xuICAuLi5vcHRpb25zLFxuICBlbmNyeXB0aW9uOiB7IC4uLm9wdGlvbnMuZW5jcnlwdGlvbiB9LFxuICBpbnRlZ3JpdHk6IHsgLi4ub3B0aW9ucy5pbnRlZ3JpdHkgfVxufSk7XG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgXCJhZXMtMTI4LWN0clwiOiB7IGtleUJpdHM6IDEyOCwgaXZCaXRzOiAxMjgsIG5hbWU6IFwiQUVTLUNUUlwiIH0sXG4gIFwiYWVzLTI1Ni1jYmNcIjogeyBrZXlCaXRzOiAyNTYsIGl2Qml0czogMTI4LCBuYW1lOiBcIkFFUy1DQkNcIiB9LFxuICBzaGEyNTY6IHsga2V5Qml0czogMjU2LCBuYW1lOiBcIlNIQS0yNTZcIiB9XG59O1xudmFyIG1hY0Zvcm1hdFZlcnNpb24gPSBcIjJcIjtcbnZhciBtYWNQcmVmaXggPSBgRmUyNi4ke21hY0Zvcm1hdFZlcnNpb259YDtcbnZhciByYW5kb21CeXRlcyA9IChfY3J5cHRvLCBzaXplKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgcmV0dXJuIGJ5dGVzO1xufTtcbnZhciByYW5kb21CaXRzID0gKF9jcnlwdG8sIGJpdHMpID0+IHtcbiAgaWYgKGJpdHMgPCAxKVxuICAgIHRocm93IEVycm9yKFwiSW52YWxpZCByYW5kb20gYml0cyBjb3VudFwiKTtcbiAgY29uc3QgYnl0ZXMgPSBNYXRoLmNlaWwoYml0cyAvIDgpO1xuICByZXR1cm4gcmFuZG9tQnl0ZXMoX2NyeXB0bywgYnl0ZXMpO1xufTtcbnZhciBwYmtkZjIgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleUxlbmd0aCwgaGFzaCkgPT4ge1xuICBjb25zdCBwYXNzd29yZEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKHBhc3N3b3JkKTtcbiAgY29uc3QgaW1wb3J0ZWRLZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgcGFzc3dvcmRCdWZmZXIsIFwiUEJLREYyXCIsIGZhbHNlLCBbXG4gICAgXCJkZXJpdmVCaXRzXCJcbiAgXSk7XG4gIGNvbnN0IHNhbHRCdWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihzYWx0KTtcbiAgY29uc3QgcGFyYW1zID0geyBuYW1lOiBcIlBCS0RGMlwiLCBoYXNoLCBzYWx0OiBzYWx0QnVmZmVyLCBpdGVyYXRpb25zIH07XG4gIGNvbnN0IGRlcml2YXRpb24gPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKHBhcmFtcywgaW1wb3J0ZWRLZXksIGtleUxlbmd0aCAqIDgpO1xuICByZXR1cm4gZGVyaXZhdGlvbjtcbn07XG52YXIgZ2VuZXJhdGVLZXkgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMpID0+IHtcbiAgdmFyIF9hO1xuICBpZiAoIShwYXNzd29yZCA9PSBudWxsID8gdm9pZCAwIDogcGFzc3dvcmQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgb3B0aW9uc1wiKTtcbiAgaWYgKCEob3B0aW9ucy5hbGdvcml0aG0gaW4gYWxnb3JpdGhtcykpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFsZ29yaXRobTogJHtvcHRpb25zLmFsZ29yaXRobX1gKTtcbiAgY29uc3QgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tvcHRpb25zLmFsZ29yaXRobV07XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBobWFjID0gKF9hID0gb3B0aW9ucy5obWFjKSAhPSBudWxsID8gX2EgOiBmYWxzZTtcbiAgY29uc3QgaWQgPSBobWFjID8geyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogYWxnb3JpdGhtLm5hbWUgfSA6IHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfTtcbiAgY29uc3QgdXNhZ2UgPSBobWFjID8gW1wic2lnblwiLCBcInZlcmlmeVwiXSA6IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdO1xuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IG9wdGlvbnMubWluUGFzc3dvcmRsZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQYXNzd29yZCBzdHJpbmcgdG9vIHNob3J0IChtaW4gJHtvcHRpb25zLm1pblBhc3N3b3JkbGVuZ3RofSBjaGFyYWN0ZXJzIHJlcXVpcmVkKWBcbiAgICAgICk7XG4gICAgbGV0IHsgc2FsdCA9IFwiXCIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzYWx0KSB7XG4gICAgICBjb25zdCB7IHNhbHRCaXRzID0gMCB9ID0gb3B0aW9ucztcbiAgICAgIGlmICghc2FsdEJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2FsdCBhbmQgc2FsdEJpdHMgb3B0aW9uc1wiKTtcbiAgICAgIGNvbnN0IHJhbmRvbVNhbHQgPSByYW5kb21CaXRzKF9jcnlwdG8sIHNhbHRCaXRzKTtcbiAgICAgIHNhbHQgPSBbLi4ubmV3IFVpbnQ4QXJyYXkocmFuZG9tU2FsdCldLm1hcCgoeCkgPT4geC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gYXdhaXQgcGJrZGYyKFxuICAgICAgX2NyeXB0byxcbiAgICAgIHBhc3N3b3JkLFxuICAgICAgc2FsdCxcbiAgICAgIG9wdGlvbnMuaXRlcmF0aW9ucyxcbiAgICAgIGFsZ29yaXRobS5rZXlCaXRzIC8gOCxcbiAgICAgIFwiU0hBLTFcIlxuICAgICk7XG4gICAgY29uc3QgaW1wb3J0ZWRFbmNyeXB0aW9uS2V5ID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJyYXdcIixcbiAgICAgIGRlcml2ZWRLZXksXG4gICAgICBpZCxcbiAgICAgIGZhbHNlLFxuICAgICAgdXNhZ2VcbiAgICApO1xuICAgIHJlc3VsdC5rZXkgPSBpbXBvcnRlZEVuY3J5cHRpb25LZXk7XG4gICAgcmVzdWx0LnNhbHQgPSBzYWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCBhbGdvcml0aG0ua2V5Qml0cyAvIDgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYnVmZmVyIChwYXNzd29yZCkgdG9vIHNtYWxsXCIpO1xuICAgIHJlc3VsdC5rZXkgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgcGFzc3dvcmQsIGlkLCBmYWxzZSwgdXNhZ2UpO1xuICAgIHJlc3VsdC5zYWx0ID0gXCJcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5pdilcbiAgICByZXN1bHQuaXYgPSBvcHRpb25zLml2O1xuICBlbHNlIGlmIChcIml2Qml0c1wiIGluIGFsZ29yaXRobSlcbiAgICByZXN1bHQuaXYgPSByYW5kb21CaXRzKF9jcnlwdG8sIGFsZ29yaXRobS5pdkJpdHMpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBlbmNyeXB0ID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgY29uc3QgdGV4dEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKGRhdGEpO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxuICAgIHsgbmFtZTogYWxnb3JpdGhtc1tvcHRpb25zLmFsZ29yaXRobV0ubmFtZSwgaXY6IGtleS5pdiB9LFxuICAgIGtleS5rZXksXG4gICAgdGV4dEJ1ZmZlclxuICApO1xuICByZXR1cm4geyBlbmNyeXB0ZWQ6IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCksIGtleSB9O1xufTtcbnZhciBkZWNyeXB0ID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5KF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuZGVjcnlwdChcbiAgICB7IG5hbWU6IGFsZ29yaXRobXNbb3B0aW9ucy5hbGdvcml0aG1dLm5hbWUsIGl2OiBrZXkuaXYgfSxcbiAgICBrZXkua2V5LFxuICAgIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9CdWZmZXIoZGF0YSkgOiBkYXRhXG4gICk7XG4gIHJldHVybiBidWZmZXJUb1N0cmluZyhuZXcgVWludDhBcnJheShkZWNyeXB0ZWQpKTtcbn07XG52YXIgaG1hY1dpdGhQYXNzd29yZCA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucywgZGF0YSkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZW5lcmF0ZUtleShfY3J5cHRvLCBwYXNzd29yZCwgeyAuLi5vcHRpb25zLCBobWFjOiB0cnVlIH0pO1xuICBjb25zdCB0ZXh0QnVmZmVyID0gc3RyaW5nVG9CdWZmZXIoZGF0YSk7XG4gIGNvbnN0IHNpZ25lZCA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLnNpZ24oeyBuYW1lOiBcIkhNQUNcIiB9LCBrZXkua2V5LCB0ZXh0QnVmZmVyKTtcbiAgY29uc3QgZGlnZXN0ID0gYmFzZTY0dXJsRW5jb2RlKG5ldyBVaW50OEFycmF5KHNpZ25lZCkpO1xuICByZXR1cm4geyBkaWdlc3QsIHNhbHQ6IGtleS5zYWx0IH07XG59O1xudmFyIG5vcm1hbGl6ZVBhc3N3b3JkID0gKHBhc3N3b3JkKSA9PiB7XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgfHwgcGFzc3dvcmQgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHJldHVybiB7IGVuY3J5cHRpb246IHBhc3N3b3JkLCBpbnRlZ3JpdHk6IHBhc3N3b3JkIH07XG4gIGlmIChcInNlY3JldFwiIGluIHBhc3N3b3JkKVxuICAgIHJldHVybiB7IGlkOiBwYXNzd29yZC5pZCwgZW5jcnlwdGlvbjogcGFzc3dvcmQuc2VjcmV0LCBpbnRlZ3JpdHk6IHBhc3N3b3JkLnNlY3JldCB9O1xuICByZXR1cm4geyBpZDogcGFzc3dvcmQuaWQsIGVuY3J5cHRpb246IHBhc3N3b3JkLmVuY3J5cHRpb24sIGludGVncml0eTogcGFzc3dvcmQuaW50ZWdyaXR5IH07XG59O1xudmFyIHNlYWwgPSBhc3luYyAoX2NyeXB0bywgb2JqZWN0LCBwYXNzd29yZCwgb3B0aW9ucykgPT4ge1xuICBpZiAoIXBhc3N3b3JkKVxuICAgIHRocm93IEVycm9yKFwiRW1wdHkgcGFzc3dvcmRcIik7XG4gIGNvbnN0IG9wdHMgPSBjbG9uZShvcHRpb25zKTtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKSArIChvcHRzLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7XG4gIGNvbnN0IG9iamVjdFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iamVjdCk7XG4gIGNvbnN0IHBhc3MgPSBub3JtYWxpemVQYXNzd29yZChwYXNzd29yZCk7XG4gIGNvbnN0IHsgaWQgPSBcIlwiIH0gPSBwYXNzO1xuICBpZiAoaWQgJiYgIS9eXFx3KyQvLnRlc3QoaWQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFzc3dvcmQgaWRcIik7XG4gIGNvbnN0IHsgZW5jcnlwdGVkLCBrZXkgfSA9IGF3YWl0IGVuY3J5cHQoX2NyeXB0bywgcGFzcy5lbmNyeXB0aW9uLCBvcHRzLmVuY3J5cHRpb24sIG9iamVjdFN0cmluZyk7XG4gIGNvbnN0IGVuY3J5cHRlZEI2NCA9IGJhc2U2NHVybEVuY29kZShuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpKTtcbiAgY29uc3QgaXYgPSBiYXNlNjR1cmxFbmNvZGUoa2V5Lml2KTtcbiAgY29uc3QgZXhwaXJhdGlvbiA9IG9wdHMudHRsID8gbm93ICsgb3B0cy50dGwgOiBcIlwiO1xuICBjb25zdCBtYWNCYXNlU3RyaW5nID0gYCR7bWFjUHJlZml4fSoke2lkfSoke2tleS5zYWx0fSoke2l2fSoke2VuY3J5cHRlZEI2NH0qJHtleHBpcmF0aW9ufWA7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNXaXRoUGFzc3dvcmQoX2NyeXB0bywgcGFzcy5pbnRlZ3JpdHksIG9wdHMuaW50ZWdyaXR5LCBtYWNCYXNlU3RyaW5nKTtcbiAgY29uc3Qgc2VhbGVkID0gYCR7bWFjQmFzZVN0cmluZ30qJHttYWMuc2FsdH0qJHttYWMuZGlnZXN0fWA7XG4gIHJldHVybiBzZWFsZWQ7XG59O1xudmFyIGZpeGVkVGltZUNvbXBhcmlzb24gPSAoYSwgYikgPT4ge1xuICBsZXQgbWlzbWF0Y2ggPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggPyAwIDogMTtcbiAgaWYgKG1pc21hdGNoKVxuICAgIGIgPSBhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpXG4gICAgbWlzbWF0Y2ggfD0gYS5jaGFyQ29kZUF0KGkpIF4gYi5jaGFyQ29kZUF0KGkpO1xuICByZXR1cm4gbWlzbWF0Y2ggPT09IDA7XG59O1xudmFyIHVuc2VhbCA9IGFzeW5jIChfY3J5cHRvLCBzZWFsZWQsIHBhc3N3b3JkLCBvcHRpb25zKSA9PiB7XG4gIGlmICghcGFzc3dvcmQpXG4gICAgdGhyb3cgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgY29uc3Qgb3B0cyA9IGNsb25lKG9wdGlvbnMpO1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKTtcbiAgY29uc3QgcGFydHMgPSBzZWFsZWQuc3BsaXQoXCIqXCIpO1xuICBpZiAocGFydHMubGVuZ3RoICE9PSA4KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2Ygc2VhbGVkIGNvbXBvbmVudHNcIik7XG4gIGNvbnN0IHByZWZpeCA9IHBhcnRzWzBdO1xuICBsZXQgcGFzc3dvcmRJZCA9IHBhcnRzWzFdO1xuICBjb25zdCBlbmNyeXB0aW9uU2FsdCA9IHBhcnRzWzJdO1xuICBjb25zdCBlbmNyeXB0aW9uSXYgPSBwYXJ0c1szXTtcbiAgY29uc3QgZW5jcnlwdGVkQjY0ID0gcGFydHNbNF07XG4gIGNvbnN0IGV4cGlyYXRpb24gPSBwYXJ0c1s1XTtcbiAgY29uc3QgaG1hY1NhbHQgPSBwYXJ0c1s2XTtcbiAgY29uc3QgaG1hYyA9IHBhcnRzWzddO1xuICBjb25zdCBtYWNCYXNlU3RyaW5nID0gYCR7cHJlZml4fSoke3Bhc3N3b3JkSWR9KiR7ZW5jcnlwdGlvblNhbHR9KiR7ZW5jcnlwdGlvbkl2fSoke2VuY3J5cHRlZEI2NH0qJHtleHBpcmF0aW9ufWA7XG4gIGlmIChtYWNQcmVmaXggIT09IHByZWZpeClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBtYWMgcHJlZml4XCIpO1xuICBpZiAoZXhwaXJhdGlvbikge1xuICAgIGlmICghL15cXGQrJC8uZXhlYyhleHBpcmF0aW9uKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXhwaXJhdGlvblwiKTtcbiAgICBjb25zdCBleHAgPSBwYXJzZUludChleHBpcmF0aW9uLCAxMCk7XG4gICAgaWYgKGV4cCA8PSBub3cgLSBvcHRzLnRpbWVzdGFtcFNrZXdTZWMgKiAxZTMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBpcmVkIHNlYWxcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgJiYgcGFzc3dvcmQubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHBhc3N3b3JkXCIpO1xuICBsZXQgcGFzcyA9IFwiXCI7XG4gIHBhc3N3b3JkSWQgPSBwYXNzd29yZElkIHx8IFwiZGVmYXVsdFwiO1xuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInN0cmluZ1wiIHx8IHBhc3N3b3JkIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICBwYXNzID0gcGFzc3dvcmQ7XG4gIGVsc2UgaWYgKCEocGFzc3dvcmRJZCBpbiBwYXNzd29yZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBwYXNzd29yZDogJHtwYXNzd29yZElkfWApO1xuICBlbHNlXG4gICAgcGFzcyA9IHBhc3N3b3JkW3Bhc3N3b3JkSWRdO1xuICBwYXNzID0gbm9ybWFsaXplUGFzc3dvcmQocGFzcyk7XG4gIGNvbnN0IG1hY09wdGlvbnMgPSBvcHRzLmludGVncml0eTtcbiAgbWFjT3B0aW9ucy5zYWx0ID0gaG1hY1NhbHQ7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNXaXRoUGFzc3dvcmQoX2NyeXB0bywgcGFzcy5pbnRlZ3JpdHksIG1hY09wdGlvbnMsIG1hY0Jhc2VTdHJpbmcpO1xuICBpZiAoIWZpeGVkVGltZUNvbXBhcmlzb24obWFjLmRpZ2VzdCwgaG1hYykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIGhtYWMgdmFsdWVcIik7XG4gIGNvbnN0IGVuY3J5cHRlZCA9IGJhc2U2NHVybERlY29kZShlbmNyeXB0ZWRCNjQpO1xuICBjb25zdCBkZWNyeXB0T3B0aW9ucyA9IG9wdHMuZW5jcnlwdGlvbjtcbiAgZGVjcnlwdE9wdGlvbnMuc2FsdCA9IGVuY3J5cHRpb25TYWx0O1xuICBkZWNyeXB0T3B0aW9ucy5pdiA9IGJhc2U2NHVybERlY29kZShlbmNyeXB0aW9uSXYpO1xuICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBkZWNyeXB0KF9jcnlwdG8sIHBhc3MuZW5jcnlwdGlvbiwgZGVjcnlwdE9wdGlvbnMsIGVuY3J5cHRlZCk7XG4gIGlmIChkZWNyeXB0ZWQpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjcnlwdGVkKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgeyBhbGdvcml0aG1zLCBiYXNlNjR1cmxEZWNvZGUsIGJhc2U2NHVybEVuY29kZSwgYnVmZmVyVG9TdHJpbmcsIGNsb25lLCBkZWNyeXB0LCBkZWZhdWx0cywgZW5jcnlwdCwgZ2VuZXJhdGVLZXksIGhtYWNXaXRoUGFzc3dvcmQsIG1hY0Zvcm1hdFZlcnNpb24sIG1hY1ByZWZpeCwgcmFuZG9tQml0cywgc2VhbCwgc3RyaW5nVG9CdWZmZXIsIHVuc2VhbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/iron-webcrypto/dist/index.js\n");

/***/ })

};
;